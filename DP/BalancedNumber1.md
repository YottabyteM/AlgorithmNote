### 写在前面

这篇题解是笔者的第一次尝试，因为是初学菜鸡，所以尝试写一些初学级别的理解，鉴于本人水平有限，表述略显冗余，请大家原谅，也欢迎大家提出宝贵的意见。

### 题目描述

求给定区间 $[X,Y]$ 中满足下列条件的整数个数：这个数恰好等于 K 个互不相等的 B 的整数次幂之和。

#### 样例
输入样例
```
15 20
2
2
```
输出样例
```
3
```
样例解释
$17$ = $2^4+2^0$
$18$ = $2^4+2^1$
$20$ = $2^4+2^2$

#### C++ 代码
```
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
const int N = 35;
int f[N][N], K, B;

void init()
{
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j <= i; j ++ )
            if (!j) f[i][j] = 1;
            else f[i][j] = f[i - 1][j] + f[i - 1][j - 1];
}

int dp(int n)
{
    if (!n) return 0;
    vector <int> nums;
    while (n) nums.push_back(n % B), n /= B;
    int res = 0, last = 0;
    for (int i = nums.size() - 1; i >= 0; i --)
    {
        int x = nums[i];
        if (x)
        {
            res += f[i][K - last];//这个位置放0，它后面的数（有i个）放剩下的1，一定成功
            if (x > 1)//一眼望尽
            {
                if (K - last - 1 >= 0) res += f[i][K - last - 1]; 
                break;
            }
            else {//不自由，后续需要进一步地计算
                last ++;
                if (K < last) break;
            }
        }
        if (!i && K == last) res ++;
    }
    return res;
}

int main()
{
    init();
    int l, r;
    cin >> l >> r >> K >> B;
    
    cout << dp(r) - dp(l - 1) << endl;
    return 0;
}
```
### 思路分析
这是一道数位dp的题目，这一类大概就是求区间内满足某种性质的数的个数总和。

一般的我们会采取如下的思路：
1. 利用前缀和优化解题。
2. 利用树的思想去解题。（我感觉就是分类的思想）

首先我们从题目可以知道的信息或者说是限制条件如下：
1. 个数恰好为K个。（这是一个重要的边界条件）
2. 互不相等。（也就是说每个整数次幂的系数都只能是1或者0）

蒟蒻讲一下**自己**对参考解法的理解或者说思路历程：

#### 简单的想法：
1. 将该数转化为B进制下的数（假设这个数有x位）。
2. 在这x个位置里放K个1。

~~这时候我们就愉快地发现答案就是 $ C^{K}_{x}$ !~~

这显然是不对的，我们可以轻松举出反例，比如说这个数B进制下为10101010,那么所计算的例子里面必然会有11xxxxxx这样的存在，这些显然是不符合规则的，所以上限是我们要考虑的一个因素。
那么怎么保证不超过这个上限呢，我们可以从之前失败的经历发现，违规的原因在于位置的随意，所以我们要从位置上面下手，也就是说，如果这个位置上比1还小，那这个位置肯定是不能放1的。那么我们顺着第一个分类依据继续思考，如果是等于甚至大于1，那么我们是不是就可以放置1和0？
以上是我思考的第一阶段。

#### 第二阶段：
既然都已经明确了每个位置放置的策略了，那么我们要想解决这个问题，是不是就得把这些位置联系起来呢？~~（毕竟标题写着是dp）~~不难发现的是前一个位置是否放1对下一个位置能否放置1是有影响的，如果说这个位置把1用完了，那么剩下就不需要计算了。之后就该建立关系式了，我首先想到了
$总策略数 = 前策略数 × 后策略数$
这里说的前策略数就是我们在当前位置已经得到的一个结果，而×后策略数的意思就是我前后的关系是可以进行相乘的。这也很容易证明是不对的，这是因为当前半部分和后半部分的一部分情况是有对应的。虽然这个幼稚的想法是错误的，但是我们也发现了前面的分布确定后，后面的分布是直接可以算出来的，也就是$C_{N_剩}^{K_剩}$。
~~这时候我们开心地发现，答案就是$\sum_{i} {C_{N_i}^{K_i}}$~~
这显然和前面的错误是一样的：
如果这个位置是大于1的数，那么我们可以100%保证这个数是合法的，也就是可以拿公式算的。而如果这个地方的数就是1，那么我们就该去考虑后续数字的放置是否会影响到数的合法性，这样我们就自然而然地和参考思路接了轨。（这里再解释一下为什么是加法：因为是完整的数的分布，不存在前后部分，同时是彼此独立的，所以我们可以累加所有种数，因为笔者在这个地方疑惑了很长时间，所以强调一下）
####整理一下：
问题相当于在问特定情况1的分布，主要矛盾是每一个位置放置1都收到前面的影响，但是并不是完全被影响，也就是说有很自由的一部分情况，是可以直接可以算出来的，所以我们分类如下：

1. 如果是相对自由的情况，我们就可以利用组合数直接计算。
2. 如果有限制，比如说这个位置值为1的话，那么我们放1时，后面的布局就不自由了，而放0时则可以归于第一种自由的情况。不自由的情况我们难以讨论，但是我们同样可以通过在那个位置放一个自由的数字把剩下的情况继续缩小，这样就形成了参考解法。
注：都是自由情况，但是一个用了1一个没有用1，所以是两种情况。

当然了这种做法对我这种初学蒟蒻还是不够自然，加上闫氏dp分析法，也就是尝试利用集合的角度去思考，可能好一些。初始时候这个集合是很乱的，没有一个稳定的关系，所以我们要尝试将集合划分，只不过我之前听到的是二阶的递推关系，而这次这个感觉仅仅就是一阶的划分？这样一想感觉就自然多了。

上面这些是我在思考这个题目以及研究参考解法的思路，下面是对一些我觉得会有疑惑的情况的描述：
```
        if (x)
        {
            res += f[i][K - last]; //此处为0
            if (x > 1)
            {
                if (K - last - 1 >= 0) res += f[i][K - last - 1]; //此处为1
                break;
            }
            else {
                last ++;
                if (K < last) break;
            }
        }
        if (!i && K == last) res ++;
```
问题1：为什么只有x不为0的情况？
答：因为如果x==0那么它就丧失了自由的机会，为0。
问题2：为什么会有第一个break出现，后期退出的话，那后几位的情况怎么算？
答：如果x>1，那么说明后续只有完全自由的情况。
问题3：有没有这种可能，我们遍历完了但是没用完1，也就是说我们为了自由一直妥协，最后出现K > last？
答：当然可以出现。想一种极端情况100101010，K = 7，这显然是没有方案的。
问题4：为什么最后还要+1？
答：这是对应不自由的情况。如果我们到了最后一位但是发现这个地方只能是0，那么它只有一种情况。换一种说法，这是i = 1 位置处不自由的情况，在上一层循环我们是留下来没有算的，所以到了下一层要加个1。

组合数的求法：
一种理解：我们从n件物品中选i件，我们可以从第一件进行分类：
如果我们拿这一件。那么之后只需要从n-1件中再拿k-1件，如果我们不拿这一件，那么我们还得再拿k件。
从而得到
$$C_{n}^{K} = C_{n - 1}^{K - 1} + C_{n - 1}^{K}$$